const Discord = require('discord.js')
const ms = require('ms')
const client = new Discord.Client()
const {prefix, token, applicationURL, memberRole, trialRole, fullMemberRole, inactiveRole, applicationChannel, staffChannel, pollChannel, memberChannel} = require('./config.json')

// Setup for auth token & reaction emoji id arrays. Note that everything is using their ids
let authTokens = []
let reactionEmojis = ['780549171089637376', '780549170770870292', '780548158068621355'] // Agree, disagree, neutral

client.login(token)

// Startup, dms Owner of the bot that it is online, sets activity
client.on('ready', async () => {
    const embed = new Discord.MessageEmbed()
        .setDescription(`${client.user.tag} is online!`);
    let owner = await client.users.fetch('213585513326706690')
    owner.send(embed)
    client.user.setActivity('over Khaos Applications', { type : "WATCHING" })
    console.log('Bot is up and running!')
});

client.on('message', async message => {

    // Checks if webhook, valid auth token, is from #applications channel, otherwise deletes message. if those are true, then add reactions
    if(message.channel == applicationChannel) {
        var attemptedAuthToken = message.embeds[0].fields[0].value.toString()
        if(authTokens.includes(attemptedAuthToken) && (message.webhookID != null)) {
        await message.react(reactionEmojis[0]) // These 3 are for voting, remove them if you do not want them.
        await message.react(reactionEmojis[1])
        await message.react(reactionEmojis[2])
        const index = authTokens.indexOf(attemptedAuthToken);
        if (index > -1) {
        authTokens.splice(index, 1);
        }
        message.guild.channels.cache.get(staffChannel).send(`User ${message.embeds[0].fields[1].value} applied using token ${attemptedAuthToken}`)
        } else { message.delete().catch() }
    };

    // Args and command variable, also checks if user is not a bot.
    if (!message.content.startsWith(prefix) || message.author.bot) return;
    const args = message.content.slice(prefix.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();

    // Apply command, will generate an authentication token and a prefilled link including it as an answer, wont work if author doesnt have member role
    if(command == 'apply' && message.member.roles.cache.get(memberRole)) {

        // Generate new auth token, if it already exists make a new one, then push to array with auth tokens and setup embeds which gets sent.
        var newAuthToken = require('crypto').randomBytes(32).toString('hex')
        if(authTokens.includes(newAuthToken)) { newAuthToken = require('crypto').randomBytes(32).toString('hex') }
        authTokens.push(newAuthToken)

        const embed = new Discord.MessageEmbed()
            .setTitle('Click here to apply!')
            .setURL(applicationURL + newAuthToken)
            .setDescription('Authentication token is included in the URL, your application will not work without it.')
            .setColor(0x00ff40)
            .setFooter(message.author.tag, message.author.avatarURL());
        
        const embed2 = new Discord.MessageEmbed()
        .setTitle('New Token Generated!')
        .setDescription(newAuthToken)
        .setColor(0xff7f50)
        .setFooter(`Generated by ${message.author.tag} in #${message.channel.name}`, message.author.avatarURL());

        message.channel.send(embed)
        message.guild.channels.cache.get(staffChannel).send(embed2)
    };

    // Remove Auth Tokens if needed, needs to be able to manage servers for this.
    if(command === 'removetoken' && message.member.hasPermission('MANAGE_GUILD')) {
        if(!args[0]) return message.channel.send('You need to input a token!')
        const index = authTokens.indexOf(args[0]);
        if (index > -1) {
        authTokens.splice(index, 1);
        }
        message.guild.channels.cache.get(staffChannel).send(`Removed token ${args[0]}`)
    };

    // Add Auth Tokens if needed, needs to be able to manage servers for this.
    if(command === 'addtoken' && message.member.hasPermission('MANAGE_GUILD')) {
        if(!args[0]) return message.channel.send('You need to input a token!')
        authTokens.push(args[0])
        message.guild.channels.cache.get(staffChannel).send(`Added token ${args[0]}`)
    };

    // See list of auth tokens, needs to be able to manage servers for this.
    if(command === 'listtoken' && message.member.hasPermission('MANAGE_GUILD')) {
        if(authTokens.length == 0) return message.channel.send('No active tokens currently.');
        var listTokens = 'Tokens:\n'
        console.log(authTokens.length)
        for(i = 0; i < authTokens.length; i++) {
            console.log(i)
            console.log(authTokens[i])
            listTokens += authTokens[i] + `\n` 
        }
        const embed = new Discord.MessageEmbed()
        .setTitle('List of tokens!')
        .setDescription(listTokens)
        .setFooter(message.author.username, message.author.avatarURL())
        message.guild.channels.cache.get(staffChannel).send(embed)
    };

    // Poll command, remind me to add multiple choice option to it too, only works with member role
    if(command === 'poll' && message.member.roles.cache.get(memberRole)) {

        // Delete message and do check for arguments, setup & check time and create embed for question.
        message.delete().catch()
        if(!args[1]) return message.channel.send(`Please use a valid format! (${prefix}poll [time] [Poll question]`).then(msg => {msg.delete(10000)})
        var pollTime = ms(args[0])
        if(pollTime > 604800000) return message.channel.send('Please select a smaller poll time.') // Checks if pull time is less than 7 days
        var pollQuestion = args.slice(1).join(' ')
        const embed = new Discord.MessageEmbed()
            .setTitle('Pending..')
            .setColor(0x8DEEEE)
            .setFooter(message.author.username, message.author.avatarURL())
            .setTimestamp();

        // Send poll message, react and handle the results on poll end
        var poll = await message.guild.channels.cache.get(pollChannel).send(embed)
        await poll.react(reactionEmojis[0])
        await poll.react(reactionEmojis[1])
        await poll.react(reactionEmojis[2])
        const collector = poll.createReactionCollector((reaction, user) => reaction.id == reactionEmojis[0] || reactionEmojis[1] || reactionEmojis[2], {time: pollTime})
        poll.edit(embed.setTitle(pollQuestion + `(Ends in ${args[0]})`))
        collector.on('end', collected => {

            // Filtering the collected reactions to determine the majority's opinion
            let agree = collected.filter(reaction => reaction.emoji.id == reactionEmojis[0]).size
            let disagree = collected.filter(reaction => reaction.emoji.id == reactionEmojis[1]).size
            let neutral = collected.filter(reaction => reaction.emoji.id == reactionEmojis[2]).size
            let winner;

            // Check winner then edit the poll message to announce the outcome.
            if(agree > disagree) { winner = 'The majority agrees!' }
            if(agree < disagree) { winner = 'The majority disagrees!'}
            if(agree == disagree) { winner = 'It is a tie!'}
            const editembed = new Discord.MessageEmbed()
                .setTitle(`${pollQuestion} (Over!)`)
                .setColor(0x721111)
                .addField(winner, `${agree}/${disagree + agree} people agrees.`)
                .setDescription(`${agree} people agree, ${disagree} people disagree and ${neutral} passed on this vote.`)
                .setFooter(message.author.username, message.author.avatarURL())
                .setTimestamp();
            poll.edit(editembed)
            poll.reactions.removeAll().catch();
        })
    };


    // Promote users to trial or full member, only works with those who can manage roles.
    if(command === 'promote' && message.member.hasPermission('MANAGE_ROLES')) {

        // Delete users message, check if a user was mentioned and setup embeds.
        message.delete().catch()
        var toPromote = message.mentions.members.first()
        if(!toPromote) return message.channel.send('You need to mention a user to promote!')

        const trial = new Discord.MessageEmbed()
            .setTitle(`${toPromote.user.username} was promoted to Trial Member!`)
            .setColor(message.guild.roles.cache.get(trialRole).color)
            .setDescription(`Promoted by ${message.author.username}`)
            .setFooter(toPromote.user.tag, toPromote.user.avatarURL());

        const fullMember = new Discord.MessageEmbed()
            .setTitle(`${toPromote.user.username} was promoted to Full Member!`)
            .setColor(message.guild.roles.cache.get(fullMemberRole).color)
            .setDescription(`Promoted by ${message.author.username}`)
            .setFooter(toPromote.user.tag, toPromote.user.avatarURL());

        // Promote user if they dont have all member role
        if(!toPromote.roles.cache.get(memberRole)) {
            try {
                toPromote.roles.add(trialRole)
                toPromote.roles.add(memberRole)
                message.guild.channels.cache.get(memberChannel).send(trial)
            } catch { message.channel.send(`Oopsie! Failed to add roles. Please check my permissions.`).then(msg => {msg.delete(10000)}) }
                return;}
    
        // Promote user if they have trial role
        if(toPromote.roles.cache.get(memberRole)) {
            try {
                toPromote.roles.remove(trialRole)
                toPromote.roles.add(fullMemberRole)
                message.guild.channels.cache.get(memberChannel).send(fullMember)
            } catch {
                message.channel.send(`Oopsie! Failed to add roles. Please check my permissions.`).then(msg => {msg.delete(10000)}) }
            return; }
        };

        // Inactive command for members to self assign to
        if(command == 'inactive' && message.member.roles.cache.get(fullMemberRole)) {
            message.delete().catch()
            var reason = args
            if(!args) reason = 'Member did not specify reason' 

            // Check if member has inactive role, if so, remove it
            if(!(message.member.roles.cache.get(inactiveRole))) {
                const embed = new Discord.MessageEmbed()
                .setTitle(`${message.author.username} has invoked inactive status!`)
                .setDescription(reason)
                .setAuthor(message.author.tag)
                .setThumbnail(message.author.avatarURL())
                .setColor(message.guild.roles.cache.get(inactiveRole).color)
                .setTimestamp();

                message.guild.channels.cache.get(memberChannel).send(embed)
                message.member.roles.add(inactiveRole)
            } else {
                const embed = new Discord.MessageEmbed()
                .setTitle(`${message.author.username} has revoked inactive status!`)
                .setDescription(reason)
                .setAuthor(message.author.tag)
                .setThumbnail(message.author.avatarURL())
                .setColor(message.guild.roles.cache.get(fullMemberRole).color)
                .setTimestamp();

                message.guild.channels.cache.get(memberChannel).send(embed)
                message.member.roles.remove(inactiveRole)
            }
        };
});